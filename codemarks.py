import sublime, sublime_plugin, os
import collections
import json

# add our codemarks cache folder if !exists
def plugin_loaded():
	
	directory = '{:s}/User/codemarks'.format( sublime.packages_path() )
	
	if not os.path.exists(directory):
	
		os.makedirs(directory)

def Log( message ):
	
	if Settings().get( 'verbose', False ):
	
		print('[codemarks] ' + message)

def Settings():

    return sublime.load_settings( 'codemarks.sublime-settings' )

def Variable( var, window=None):
	
	window = window if window else sublime.active_window()
	
	return sublime.expand_variables(var, window.extract_variables())

# convert marks-as-tuples back into sublime.Regions
def UnhashMarks( marks ):
	
	newMarks = []
	
	for mark in marks:
	
		newMarks.append(sublime.Region(mark[0], mark[1]))

	return newMarks

# convert sublime.Region into mark-as-tuple
def HashMarks( marks ):
	
	newMarks = []
	
	for mark in marks:
		
		newMarks.append((mark.a, mark.b))

	return newMarks

# convert sublime.Region into string
class RegionJSONCoder( json.JSONEncoder ):
	
	def default( self, obj ):
	
		if isinstance( obj, sublime.Region ):
	
			return {
	
				'__type__': 'sublime.Region',
				'a': obj.a,
				'b': obj.b,
	
			}
	
		return json.JSONEncoder.default(self, obj)

	@staticmethod

	def dict_to_object( d ):
		
		if '__type__' not in d:
		
			return d

		type = d.pop('__type__')
		
		if type == 'sublime.Region':
		
			return sublime.Region(d.pop('a'), d.pop('b'))
		
		else:
		
			d['__type__'] = type
		
			return d

class CodemarksCommand(sublime_plugin.TextCommand):
	
	def __init__( self, edit ):
	
		sublime_plugin.TextCommand.__init__( self, edit )
	
		self.filename = Variable( '${file_name}' )
	
		self.layers = collections.deque( Settings().get( 'layer_icons' ) )
	
		self.layer = Settings().get( 'default_layer' )
	
		while not self.layers[0] == self.layer:
	
			self.layers.rotate(1)
	
		self.marks = {}
	
		for layer in Settings().get( 'layer_icons' ):
	
			self.marks[layer] = []

	def _is_empty( self ):
		
		for layer in self.layers:
		
			if self.marks[layer]:
		
				return False

		return True

	# path to cache file
	def _marks(self):

		return '{:s}/User/codemarks/{:s}.cm_cache'.format( sublime.packages_path(), self.filename.replace( '.', '-' ) )

	# render current layer marks
	def _render( self ):
		
		marks = UnhashMarks(self.marks[self.layer])
		
		icon = Settings().get( 'layer_icons' )[self.layer]['icon']
		
		scope = Settings().get( 'layer_icons' )[self.layer]['scope']

		self.view.add_regions( 'bookmarks', marks, scope, icon, sublime.PERSISTENT | sublime.HIDDEN )

	# add list of marks to existing list
	def _add_marks( self, newMarks, layer=None ):
		
		layer = layer if layer else self.layer
		
		marks = []

		if newMarks:
		
			if not layer in self.marks:
		
				self.marks[layer] = []

			marks = self.marks[layer]

			for mark in newMarks:
		
				if mark in marks:
		
					marks.remove(mark)
		
				else:
		
					marks.append(mark)

		self.marks[layer] = marks

		if layer == self.layer:
		
			self._render()

	# jump to selected layer
	def _change_to_layer( self, layer ):
		
		self.layer = layer
		
		status_name = 'code_layer_status'

		status = Settings().get( 'layer_status_location', ['permanent'] )

		if 'temporary' in status:
			
			sublime.status_message( self.layer )
		
		if 'permanent' in status:
			
			self.view.set_status( status_name, 'codemark layer: {:s}'.format( self.layer ) )
		
		else:
			
			self.view.erase_status( status_name )
		
		if 'popup' in status:
		
			if self.view.is_popup_visible():
		
				self.view.update_popup( self.layer )
		
			else:
		
				self.view.show_popup( self.layer , 0, -1, 1000, 1000, None, None)

		self._render()

	def _save_marks( self ):
		
		if not self._is_empty():
		
			Log( 'Saving BBFile for ' + self.filename )
		
			with open( self._marks(), 'w') as fp:
		
				json.dump( self.marks, fp, cls=RegionJSONCoder )

	def run( self, edit, **args ):
		
		view = self.view
		
		subcommand = args['subcommand']

		if subcommand == 'mark_line':
		
			selection = view.sel()
		
			if Settings().get( 'mark_whole_line', False):
		
				selection = view.lines( selection[0] )
		
			line = args['line'] if 'line' in args else HashMarks( selection )
			
			layer = args['layer'] if 'layer' in args else self.layer

			self._add_marks( line, layer )
		
		elif subcommand == 'clear_marks':
		
			layer = args['layer'] if 'layer' in args else self.layer
		
			self._add_marks([], layer)
		
		elif subcommand == 'clear_all':
		
			for layer in self.layers:
		
				self._add_marks([], layer)
		
		elif subcommand == 'layer_swap':
		
			direction = args.get( 'direction' )
		
			if direction == 'prev':
		
				self.layers.rotate(-1)
		
			elif direction == 'next':
		
				self.layers.rotate(1)
		
			else:
		
				sublime.error_message( 'invalid layer swap' )

			self._change_to_layer(self.layers[0])
		
		elif subcommand == 'on_load':
		
			Log( 'Loading BBFile for ' + self.filename )
		
			try:
				
				with open( self._marks(), 'r' ) as fp:
					
					marks = json.load(fp, object_hook=RegionJSONCoder.dict_to_object)
					
					for layer, regions in marks.items():
					
						self.marks[layer] = regions
			
			except Exception as e:
			
				pass
			
			self._change_to_layer( Settings().get( 'default_layer' ) )
		
		elif subcommand == 'on_save':
		
			self._save_marks()
		
		elif subcommand == 'on_close':
			
			if Settings().get( 'cache_marks_on_close', False ):
			
				self._save_marks()
			
			if self._is_empty():
			
				Log( 'Removing BBFile for ' + self.filename )
			
				try:
			
					os.remove( self._marks() )
			
				except FileNotFoundError as e:
			
					pass

class CodemarksEventListener(sublime_plugin.EventListener):
	
	def __init__(self):
		
		sublime_plugin.EventListener.__init__(self)

	def _contact(self, view, subcommand):
		
		view.run_command( 'codemarks_fx', {

			'subcommand': subcommand

		})

	def on_load_async(self, view):
		
		if Settings().get('uncache_marks_on_load'):
		
			self._contact(view, 'on_load')

	def on_pre_save(self, view):
		
		if Settings().get('cache_marks_on_save'):
		
			self._contact(view, 'on_save')

	def on_close(self, view):
		
		if view.file_name() and Settings().get('cleanup_empty_cache_on_close'):
			
			self._contact(view, 'on_close')
